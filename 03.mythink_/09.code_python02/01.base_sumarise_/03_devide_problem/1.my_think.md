
分治法，顾名思义，是把问题的规模逐步缩小到可以求解的状态，然后堆叠出问题的解。

分治法的难点在于判断这个问题是否应该使用分治法，如何进行分治，有点类似于贪婪算法中的贪婪策略。

比如二分查找，这种问题的分治模式十分明了，一看便知，但是有些情况的分治模式是并不容易找到的。
比如求前k大，也可以使用分治法，这种也是挺有效的，但是不太容易想起来的，主要是因为这个分治的策略比较隐蔽，而且分治后结果并不直观。
例如：
在二分查找中，
对于有序数组，很直观的可以从中间查起，这样一次可以排除掉一半,
在这个过程中问题的解一直没有变，就是查找目标数据，但是问题的规模逐渐变小了

对于前k大问题
那么如何将问题规模变小呢，这里采用的是任选一个作为标兵，将问题进行二分（不一定是均等二分），然后问题的规模就变成了从剩下的数据中求解了，
当然这里可能问题的规模和求解的结果同时都变了（取决于分出来的较大的组合的元素个数是否大于k）
这种任选一个作为标志的方式不太容易想到，可以作为一个思考模式存在。就是推断的思维更加深入一些。



分治有两种形式:
1. 求解的结果不变，逐渐缩小问题的规模
2. 逐步缩减求解的结果和问题。


分治法的实现模式可以是递归方式，也可以是非递归方式

能使用分治法解决的问题一般都具有两个显著的特点，
第一个特点是问题可以分解为若干个规模较小的相同问题，并且这个分解关系可以用递归或递推的方式逐级分解，直到问题的规模小到可以直接求解的程度

第二个特点是子问题的解可以用某种方式合并出原始问题的解。这很容易理解，如果不能合并出原始问题的解，那么子问题的划分和求解就没有意义了


递归与分治
递归作为一种算法的实现方式，与分治法是一对儿天然的好朋友。为什么这么说呢？
因为问题的分解肯定不是一步到位，往往需要反复使用分治手段，在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。
从算法实现的角度看，分治法得到的子问题和原问题是相同的，当然可以用相同的函数来解决，区别只在于问题的规模和范围不同。
通过特定的函数参数安排，使得同一个函数可以解决不同规模的相同问题，这就是递归方法的基础


数据模型的使用
分治有时候被用来解决排列组合类问题，对于排列组合类问题，数据模型有两种使用方式，一种是迭代的时候解逐渐积累，父亲不需要等子返回后再处理结果，
结果再递归调用达到最小子问题的状态就直接求解出来了，这就需要能够将父亲处理的结果传递到子问题当中。

我觉得这是数据建模的两种方式，一种是直接返回的状态，也就是由最外层的调用函数返回，有些是是设置一个内存共享变量，大家都去修改这个变量，
在所有的不同层面的修改完成后也就得到最终结果。

可能这两种模式不仅仅体现在分治当中的排列组合当中

用更容易理解的话来说，一种是父亲整合孩子的处理结果，一种是孩子整合父亲的处理结果，
当然孩子不会直接使用父亲的结果，只有在最后对结果合并的环节是发生在子当中
正常情况下是父亲合并孩子的结果，而且是在每一个层次都进行合并









































