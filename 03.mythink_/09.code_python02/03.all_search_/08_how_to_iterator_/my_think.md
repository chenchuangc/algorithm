
如何设计递归算法

个人的理解认为，递归算法的设计依赖于一种问题解决方式，就是父问题能够通过子问题的解得到求解。
就像是数学中的递推的证明一样，对于我来说这恰恰是一种反人类的思维方式，因为人类的思维方式最直接的就是感性的，敏感的，直接的，
总是上来就想看到问题的解，而不是看看问题可以如何对问题进行分解，得到递归的子问题

所以递归是一种需要培养的思维模式，对问题进行求解的时候看看有没有方法对问题进行同构分解，这样就形成了递归，
但是递归的形势大体一致，但是实际的处理当中可能因为问题的不同，又会有一些新的求解方法

## 递归问题主要关注点
1. 递归的主体是什么，也就是可以进行递归的问题结构，这些主体需要哪些数据模型才能完全包含
2. 递归的退出条件，以及在退出的时候需要做怎样的处理
3. 递归处理的自我触发机制，什么情况下回发生自我调用，递归并不总是简单的自我调用，有时候会糅合一些其他的处理，比如对于归并排序

如果归并按照这三个要素来进行分析的话，前面遇到的问题也逐渐更加清晰了

比如之前遇到的字符串的全排，在最开始的时候考虑使用递归，但是不知道如何对结果进行组合。
因为之前认为的递归就是父亲显示的组合孩子的结果，孩子总是返回一些结果，然后父亲来处理。
比如归并排序，快排，孩子都是做好自己的事儿，不会关注整体的状态，也就是最终结果都是由父亲产生，
而不是由孩子产生（其实快排已经是由孩子产生了，只是是隐式的），
但是如果在这里归纳的话，就是在退出是做了一些处理而已，孩子对整个结果做了处理，慢慢有这种认识了也就更好了
有时候真的是因为自己见的太少，所以产生了一些思维的固定模式，进而当做了认知型的知识，需要借助新的认知来打破这种狭隘的知识模式
所以，刷一定量的题还是很有必要的


## 递归常用模式
1. 同一问题的结构变形模式
这一类递归程序，有一些共同的特点，就是每次递归调用的时候，递归触发机制传递的参数还是原问题的参数，范围没有变化，只是要处理的侧重点和位置发生了变化。
换句话说，不是拆分成子问题处理的那种形式，并且触发机制产生的同一级递归调用之间没有组合关系。比如工作站问题，倒水问题。这类问题更像是在使用迭代的方式进行穷举。

2. 多阶段组合模式
这个是多个阶段是排列组合的关系，比如爱因斯坦问题，这个时候就可以使用递归的方式进行解决，但是需要记录一些中间状态

3. 分解子问题模式
分治法和递归是一对儿天然好朋友，因为分治意味着要分解子问题，而子问题就是一种天然的递归子结构，用递归方法处理分治法就是顺理成章的事情。
















































